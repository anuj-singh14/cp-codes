#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define vi vector<int>
#define vll vector<ll>
#define frw(i, a, b) for(int i = a; i < b; i++)
#define fi first
#define se second
#define pub push_back
#define in insert
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) int(a.size())
#define pii pair<int, int>
#define pll pair<ll, ll>
#define plll pair<ll, pll>
#define vpll vector<pll>

const ll N = 3e5 + 5;

//MST code taken from https://github.com/Ashishgup1/Competitive-Coding/blob/master/Prim's%20MST.cpp
//store adj list as adj[x].pub({y, w})
vpll adj[N], tree[N];
vll parent(N, 0), dist(N, 1e10);
vector<bool> vis(N, 0);

ll primsMST(ll source) //Finds the cost and makes the MST
{
	set<pll> s;
	s.in({0, source});
	ll cost = 0;
	dist[source] = 0;
	while(!s.empty())
	{
		auto x = *(s.begin());
		s.erase(s.begin());
		vis[x.se] = 1;
		cost += x.fi;
		ll u = x.se;
		ll v = parent[x.se];
		ll w = x.fi;
		tree[u].pub({v, w});
		tree[v].pub({u, w});
		for(auto it : adj[x.se])
		{
			if(vis[it.fi])
				continue;
			if(dist[it.fi] > it.se)
			{
				s.erase({dist[it.fi], it.fi});
				dist[it.fi] = it.se;
				s.in({dist[it.fi], it.fi});
				parent[it.fi] = x.se;
			}
		}
	}
	return cost;
}
